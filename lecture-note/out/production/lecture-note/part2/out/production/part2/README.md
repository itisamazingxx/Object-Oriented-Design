## Static Variable && Instance(Non-static) Variable

## Code Block
普通代码块：每创建一个实例就执行一次
静态代码块：随着类的加载而执行

**类什么时候被加载**
1. new 一个新的实例的时候
2. new一个子类的时候 父类也会被加载
3. 使用类里的静态属性 静态方法

**如果存在多个Class(有继承关系), 那么对其静态成员, 普通成员的初始化顺序是怎样的(InterviewQuestion)**
1. 父类的静态代码块，静态属性(优先级一样按定义顺序)
2. 子类的静态代码块，静态属性(优先级一样按定义顺序)
3. 父类的普通代码块，普通属性(优先级一样按定义顺序)
4. 父类的构造方法
5. 子类的普通代码块，普通属性(优先级一样按定义顺序)
6. 子类的构造方法

**Singleton**
1. 饿汉式：在类加载的时候就初始化了实例(不存在线程安全的问题)
2. 懒汉式：在使用时才创建
区别只有instance创建时间的区别

## Abstract Class
1. 抽象方法, 指没有实现的方法 (没有方法体)
2. 当一个类中存在抽象方法时, 必须把该类声明为abstract类
3. 抽象类会被继承, 由其子类实现抽象方法
4. 抽象类不能被实例化
5. 抽象类可以没有抽象方法，还可以有实现的方法
6. 抽象类本质还是类, 可以拥有任意成员
7. 如果一个类继承了抽象类, 则它必须实现抽象类中的所有方法
8. 抽象类中的抽象方法不能用private/static/final等修饰词修饰, 因为这些都跟Override相违背

## Interface
1. 接口就是给出一些没有实现的方法, 封装到一起, 到某个类要使用的时候, 再根据具体情况把这些写出来
2. JDK8.0后, 接口内可以有具体的方法实现
3. 如果一个类implement接口, 需要将接口内所有抽象方法全部实现
4. 接口不能被实例化
5. 接口中的所有方法都是public的, 默认abstract(可以不用abstract修饰词修饰)
6. 抽象类实现接口, 可以不用实现接口的方法
7. 一个类同时可以实现多个接口
8. 接口的修饰符, 只能是public或者默认
```Java
public interface InterfaceExercise {
    // 接口中可以定义属性
    // 接口中定义的所有属性都是public, static, final的类型
    public int num = 10;
    // 定义方法
    public void say();
}
```
9. 接口类型的变量可以指向实现了该接口的类的对象
```Java
 USBInterface phone = new Phone();
```
10. interface之间也可以互相继承, 如果一个类实现的一个接口本来继承了另一个接口, 那么此类实现这两个接口内所有内容(接口的多态传递)

### Interface V.S Inheritant
1. 当子类继承父类，自动拥有父类的功能
2. 如果子类需要扩展功能 可以通过实现接口的方式扩展
3. 实现接口是对Java单继承机制的一种补充

接口和继承解决的问题是不同的：
1. 继承的价值主要在于：解决代码的复用性和可维护性
2. 接口的价值在于：设计，设计好各种规范(方法)，让其他类实现这些方法

## 内部类
1. 一个类的内部又完整的嵌套了另一个类结构, 被嵌套的类称为内部类(inner class), 嵌套其他类的类被称为外部类(outer class)
2. 是类的第五大成员 (属性, 方法, 构造器, 代码块, 内部类)

### 内部类的分类
定义在方法的局部位置上(比如方法内):
1. 局部内部类(有类名)
2. **匿名内部类**(没有类名)

a. 局部内部类是定义在外部类的局部位置, 比如方法中  
b. 外部类访问局部内部类成员 先new   
c. 外部其他类不能访问局部内部类
d. 局部内部类访问外部类属性, 外部类名.this.属性名(不然遵循就近原则)

定义在外部类的成员位置上
1. 成员内部类
2. 静态内部类

### 匿名内部类
1. 匿名内部类是定义在外部类的局部位置, (比如方法中), 而且没有类名
2. 匿名内部类同时还是一个对象(本身返回对象)

### 成员内部类
1. 是定义在外部类的成员位置上
```Java
class Outer { // 外部类
    private int num = 10;
    
    class Inner {
        public void n1() {
            // 可以直接访问外部类的所有成员
            System.out.println("The value of num is " + num);
        }
    }
    
}
```
2. 可以使用修饰符(本质是外部类的一个成员)

### 静态内部类
1. 静态内部类还是定义在外部类的成员位置, 并且有static修饰符
2. 静态内部类不能访问外部类的非静态成员
3. 可以添加任意访问修饰符

## Enumeration
1. 是一种常量的集合(有限的特定对象)
2. 如果用Enum类实现枚举, 常量对象要写在最前面
3. 当我们使用enum关键字开发一个枚举类, 默认会继承Enum类, 且此类是final类型
4. Enum和其他类一样, 可以实现接口

## Annotation
1. 元数据, 用于修饰解释包/类/构造器/方法等...
2. 注解不影响程序逻辑, 相当于补充信息
3. @SuppressWarnings: 抑制编译器警告
4. @Override: 重写父类方法, 该注解只能用在方法上

## 包装类
1. 针对八大基本数据类型相应的引用类型 - 包装类
2. 基本数据类型 -> 包装类 (装箱)
3. 包装类 -> 基本数据类型 (拆箱)

##